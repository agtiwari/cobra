{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"General Cobra is a realtime messaging server using Python3, WebSockets and Redis Streams. It was presented in great details during RedisConf 2019 . Since then we've added history support which let cobra retain messages published to a channel that no-one is subscribed to. This makes it easier to blow up your systems through OOMs and fill your hard drives, but it makes cobra much more useful. slides youtube Cobra has been used in production receiving heavy traffic for about a year. Since it was written in Python it was named after a snake as an hommage to a great programming language. There are 4 operations that a client can execute against a cobra server: publish , subscribe , read and write . publish and subscribe are the 2 operations core to a group-chat. read and write are the typical operations that key value stores (such as memcached), or a python dictionnary provide. publish : send data to a channel, which will be broadcasted to anyone subscribed to that channel subscribe : receive events sent to a channel in real time. write : record some data (addressed by a key) read : retrieve data News Cobra is actively being developed, check out the changelog to know what's cooking. Installation With pip pip install cobras With docker docker pull bsergean/cobra For development git clone <url> cd cobra python3 -m venv venv source venv/bin/activate make dev make test Usage Cobra server and test clients $ cobra Usage: cobra [OPTIONS] COMMAND [ARGS]... Cobra is a realtime messaging server using Python3, WebSockets and Redis PubSub. Options: --version Show the version and exit. --help Show this message and exit. Commands: admin Run admin commands. health Health check init Setup cobra monitor Monitor cobra publish Publish to a channel run Run the cobra server redis_subscribe Subscribe to a channel (with redis) subscribe Subscribe to a channel secret Generate secrets used for authentication... To run the server use cobra run . You can run a health-check against the server with cobra health . cobra health --url 'ws://jeanserge.com/v2?appkey=_health' --secret A5a3BdEfbc6Df5AAFFcadE7F9Dd7F17E --role health bavarde bavarde is a chat client that runs against the public cobra server. Bring up 2 terminals, runs the 2 commands below and start typing. $ bavarde client ... $ bavarde client --username bob ... Setup cobras init needs to be run once to generate an app configuration file, in ~/.cobra.yaml . That file contains all the roles, secrets and apps configured. Clients will use this data to authenticate. To run in production you will need a redis (version > 5) instance. Here are environment variables that you will likely want to tweak, to connect to 2 redis instances (for scalabity), and to bind on 0.0.0.0 so that the internet can see your instance. - name: COBRA_HOST value: 0.0.0.0 - name: COBRA_REDIS_URLS value: redis://redis1;redis://redis2 # config can be a path to a file - name: COBRA_APPS_CONFIG_PATH value: /path/to/your/cobra.yaml # config can be a blob of gziped + base64 data (if you do not want to mount volumes) # Generate it with: # `gzip -c ~/.cobra.yaml | base64` - name: COBRA_APPS_CONFIG_CONTENT value: BIGBLOGOFDATA Contributing Cobra is developed on github . We'd love to hear about how you use it ; opening up an issue in github is ok for that. If things don't work as expected, please create an issue in github, or even better a pull request if you know how to fix your problem. Thank you There would be no cobra without some other amazing open-source projects and tech. Here are 3 very remarkable ones. Python (and asyncio , one of the killer python3 feature !) Redis , the swiss army knife of the internet which provide a very scalable publish/subscribe feature to dispatch messages while retaining them and allowing lookups of old messages (see [Redis Streams] (https://redis.io/topics/streams-intro). The python websockets library, very elegantly implementing the WebSockets protocol using asyncio .","title":"General"},{"location":"#general","text":"Cobra is a realtime messaging server using Python3, WebSockets and Redis Streams. It was presented in great details during RedisConf 2019 . Since then we've added history support which let cobra retain messages published to a channel that no-one is subscribed to. This makes it easier to blow up your systems through OOMs and fill your hard drives, but it makes cobra much more useful. slides youtube Cobra has been used in production receiving heavy traffic for about a year. Since it was written in Python it was named after a snake as an hommage to a great programming language. There are 4 operations that a client can execute against a cobra server: publish , subscribe , read and write . publish and subscribe are the 2 operations core to a group-chat. read and write are the typical operations that key value stores (such as memcached), or a python dictionnary provide. publish : send data to a channel, which will be broadcasted to anyone subscribed to that channel subscribe : receive events sent to a channel in real time. write : record some data (addressed by a key) read : retrieve data","title":"General"},{"location":"#news","text":"Cobra is actively being developed, check out the changelog to know what's cooking.","title":"News"},{"location":"#installation","text":"","title":"Installation"},{"location":"#with-pip","text":"pip install cobras","title":"With pip"},{"location":"#with-docker","text":"docker pull bsergean/cobra","title":"With docker"},{"location":"#for-development","text":"git clone <url> cd cobra python3 -m venv venv source venv/bin/activate make dev make test","title":"For development"},{"location":"#usage","text":"","title":"Usage"},{"location":"#cobra-server-and-test-clients","text":"$ cobra Usage: cobra [OPTIONS] COMMAND [ARGS]... Cobra is a realtime messaging server using Python3, WebSockets and Redis PubSub. Options: --version Show the version and exit. --help Show this message and exit. Commands: admin Run admin commands. health Health check init Setup cobra monitor Monitor cobra publish Publish to a channel run Run the cobra server redis_subscribe Subscribe to a channel (with redis) subscribe Subscribe to a channel secret Generate secrets used for authentication... To run the server use cobra run . You can run a health-check against the server with cobra health . cobra health --url 'ws://jeanserge.com/v2?appkey=_health' --secret A5a3BdEfbc6Df5AAFFcadE7F9Dd7F17E --role health","title":"Cobra server and test clients"},{"location":"#bavarde","text":"bavarde is a chat client that runs against the public cobra server. Bring up 2 terminals, runs the 2 commands below and start typing. $ bavarde client ... $ bavarde client --username bob ...","title":"bavarde"},{"location":"#setup","text":"cobras init needs to be run once to generate an app configuration file, in ~/.cobra.yaml . That file contains all the roles, secrets and apps configured. Clients will use this data to authenticate. To run in production you will need a redis (version > 5) instance. Here are environment variables that you will likely want to tweak, to connect to 2 redis instances (for scalabity), and to bind on 0.0.0.0 so that the internet can see your instance. - name: COBRA_HOST value: 0.0.0.0 - name: COBRA_REDIS_URLS value: redis://redis1;redis://redis2 # config can be a path to a file - name: COBRA_APPS_CONFIG_PATH value: /path/to/your/cobra.yaml # config can be a blob of gziped + base64 data (if you do not want to mount volumes) # Generate it with: # `gzip -c ~/.cobra.yaml | base64` - name: COBRA_APPS_CONFIG_CONTENT value: BIGBLOGOFDATA","title":"Setup"},{"location":"#contributing","text":"Cobra is developed on github . We'd love to hear about how you use it ; opening up an issue in github is ok for that. If things don't work as expected, please create an issue in github, or even better a pull request if you know how to fix your problem.","title":"Contributing"},{"location":"#thank-you","text":"There would be no cobra without some other amazing open-source projects and tech. Here are 3 very remarkable ones. Python (and asyncio , one of the killer python3 feature !) Redis , the swiss army knife of the internet which provide a very scalable publish/subscribe feature to dispatch messages while retaining them and allowing lookups of old messages (see [Redis Streams] (https://redis.io/topics/streams-intro). The python websockets library, very elegantly implementing the WebSockets protocol using asyncio .","title":"Thank you"},{"location":"CHANGELOG/","text":"Changelog All changes to this project will be documented in this file. [2.6.1] - 2019-12-05 (server) bump sentry_sdk dependency to 0.13.5 + set release and environment while initializing the sentry sdk [2.6.0] - 2019-12-05 (server) check that redis nodes are reachable on startup, with a timeout. $ brew services stop redis Stopping `redis`... (might take a while) ==> Successfully stopped `redis` (label: homebrew.mxcl.redis) $ cobra run runServer {'host': '127.0.0.1', 'port': '8765', 'redis_urls': 'redis://localhost;redis://localhost', 'redis_password': None, 'apps_config_path': '/Users/bsergeant/.cobra.yaml', 'apps_config_path_content': None, 'debug_memory': False, 'debug_memory_no_tracemalloc': False, 'plugins': None, 'sentry': False, 'sentry_url': None, 'prod': False, 'no_stats': False, 'max_subscriptions': -1, 'idle_timeout': 300, 'disable_redis_startup_probing': False, 'redis_startup_probing_timeout': 30} Checking redis://localhost .................................................................................................................................................... 2019-12-05 22:17:23 CRITICAL Cannot start cobra server: Multiple exceptions: [Errno 61] Connect call failed ('::1', 6379, 0, 0), [Errno 61] Connect call failed ('127.0.0.1', 6379) [2.5.5] - 2019-12-05 (client) add --tidy to the monitor subcommand to only print generic info [2.5.4] - 2019-12-04 (server) rtm/publish handler: ignore empty channels (which gets serialized as \"None\") [2.5.3] - 2019-12-04 (client) cobra health command parameters consistent with other commands (sdk) publish cobras package to npm [2.5.2] - 2019-12-02 (server) improve redis subscription logging [2.5.1] - 2019-12-02 (server + client) subscribe interface changed to receive multiple messages The --batch_size option can be specified to the subscribe sub-command to request messages to be delivered in batch. This is convenient when a subscriber expects lots of messages to be received, as it saves the various overhead of sending smaller individual messages. Notice how all msg count received are a multiple of 50 in the example below, where we request a batch size of 50 messages. ~ $ cobra subscribe --endpoint wss://example.com --appkey XXXX --rolename _sub --rolesecret YYYYYYY --channel channel_name \\ --disable_debug_memory \\ --batch_size 50 position None #messages 0 msg/s 0 position 1575316403409-2 #messages 2350 msg/s 2350 position 1575316404404-4 #messages 4550 msg/s 2200 position 1575316405414-10 #messages 6800 msg/s 2250 position 1575316406418-0 #messages 9250 msg/s 2450 position 1575316407403-8 #messages 11600 msg/s 2350 position 1575316408419-5 #messages 13900 msg/s 2300 position 1575316409394-10 #messages 16250 msg/s 2350 position 1575316410416-7 #messages 18650 msg/s 2400 ``` ## [2.5.0] - 2019-12-01 * (client) subscribe interface changed to receive multiple messages (only one at a time supported so far) ## [2.4.2] - 2019-11-19 * (server) HTTP GET / display some informations about cobra ## [2.4.1] - 2019-11-19 * make the server more resilient when dealing with stale redis connections ## [2.4.0] - 2019-11-18 * add per channel statistics for publish and subscribe ## [2.3.7] - 2019-11-13 * (deps) bump websockets lib dependency to 8.1 ## [2.3.6] - 2019-11-12 * (client) async method call needs to be awaited ## [2.3.5] - 2019-11-12 * (build) tweak requirements file, to mark sentry as a loose dependency ## [2.3.4] - 2019-11-12 * (common) Write memory statistics on stderr instead of stdout ## [2.3.3] - unreleased ## [2.3.2] - 2019-10-18 * (client) In connection code, bring back slower code which does not leak and is exception safe ## [2.3.1] - 2019-10-18 * All tasks are given an exception handler to log errors into sentry ## [2.3.0] - 2019-10-18 * Switch to rapidjson from standard json as it is noticeably faster, the only downside is that it takes longer to install / make Docker containers ## [2.2.5] - 2019-10-17 * Bump sentry_sdk dependency ## [2.2.4] - 2019-10-17 * Fix performance problem when saving the last position received when subscribing (--resume_from_last_position) ## [2.2.3] - 2019-10-17 * Docker file second layer still reference an old Python. Default read/write subcommands channel clashes with the default publish/subcribe, so make it unique. Add --repeat option to write subcommand to indefinitely write. ## [2.2.2] - 2019-10-16 * Bump to python 3.8.0 proper. getVersion utility can take a module name. ## [2.2.1] - 2019-10-16 * Fix a memory leak in the client connection class ## [2.2.0] - 2019-10-15 * Add a --debug_memory_no_tracemalloc option to cobra run to have a 'slim' memory debugging mode. ## [2.1.9] - 2019-10-15 * bump tabulate to 0.8.5 ## [2.1.8] - 2019-10-08 * bump sentry_sdk to 0.12.3 ## [2.1.7] - 2019-10-02 * redis connections from the pipelined publishers are closed when terminating the app (mostly useful to get rid of python 3.8rc1 warnings when running the unittest) ## [2.1.6] - 2019-10-01 * display all http headers when catching zlib decompression error explicitly and logging an error ## [2.1.5] - 2019-10-01 * catch zlib decompression error explicitly and log an error including the connection id ## [2.1.4] - 2019-09-30 * sentry integration / report the user agent properly using the current sentry Hub (see https://github.com/getsentry/sentry-python/issues/483) ## [2.1.3] - 2019-09-30 * redis subscription: detect max number of clients reached error and fail rtm/subscribe commands ## [2.1.2] - 2019-09-27 * fix redis connection leak in rtm/delete ## [2.1.0] - 2019-09-25 * bump aio-redis dependency to 1.3.0 ## [2.0.0] - 2019-09-19 * cobra works with python3.8 (beta4 at this point) ## [1.9.0] - 2019-09-18 * server / LIKE expression follows more closely the SQL standard, using globbing/fnmatch to evaluate expressions. LIKE can be used to compute startswith and endswith queries for strings. % (match all) and _ (match one) characters are supported, and mapped to * and ? fnmatch globbing special characters. ## [1.8.2] - 2019-09-17 * server / add a channel_max_length apps config parameter that limits how many messages can be retained in a single channel. Still default to a 1000 messages. The parameter is a global, top level yaml config for now. It is likely that we will make it a per appkey settings. In the example below we set it to 100. This parameter is helpful if you are trying to use cobra to transfer large messages. $ head ~/.cobra.yaml batch_publish_size: 50 channel_max_length: 100 ## [1.8.1] - 2019-09-17 * server / user-agent recorded as a sentry context info is a python 3.7 Context Variable * server / log a warning instead of an error when a connection is made with an invalid appkey ## [1.8.0] - 2019-09-17 * server / record user-agent as a sentry context info ## [1.7.9] - 2019-09-17 * server / log an error when a connection is made with an invalid appkey ## [1.7.8] - 2019-09-11 * server / return metadata about a stream (existence and length) when subscribing to a channel (in the body response) ## [1.7.7] - 2019-09-11 * bump sentry_sdk dep to 0.11.2 ## [1.7.6] - 2019-09-11 * server / connection state holds a userAgent and has a __repr__ method, this should work with sentry errors to identify bad clients ## [1.7.5] - 2019-09-11 * server / connection id is 12 byte long, instead of 8. This might help with some rare collisions. ## [1.7.4] - 2019-09-10 * server / make disk logging work on Windows by using tempfile.gettempdir() instead of /tmp/ ## [1.7.3] - 2019-09-09 * client / when closing a connection, make sure to unsubscribe all subscriptions ## [1.7.1] - 2019-08-29 ### Changed * bump click version ## [1.7.0] - 2019-08-28 ### Changed * rtm/delete delete a stream, instead of writing a null entry in it * health check delete temp channel/streams + test read/write/delete ## [1.6.12] - 2019-08-28 ### Changed * Add optional http test in health-check, with --http_extra_check ## [1.6.11] - 2019-08-28 ### Fixed * Fixed a couple of pylint warnings * Stop depending on ujson ## [1.6.10] - 2019-08-24 ### Changed * Upgrade uvloop dependency to 0.13.0 to hopefully solve [Fatal error on transport TCPTransport](https://github.com/MagicStack/uvloop/issues/244) kind of errors. * Dockerfile uses Python 3.7.4 ## [1.6.9] - 2019-08-23 ### Fixed Missing __init__.py file required to have a the handlers folder loaded. ## [1.6.8] - 2019-08-23 ### Changed - (client) New --summary option for cobra publish, usually used to see how many messages can be sent to a server per second (venv) cobra$ cobra publish --url 'ws://jeanserge.com/v2?appkey=_health' --repeat --delay 0.001 --secret A5a3BdEfbc6Df5AAFFcadE7F9Dd7F17E --role health Processing 1 items 1 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds ^C Aborted! ## [1.6.7] - 2019-08-21 ### Changed - More unittest to test failures in pubsub and health-checks. Above 80% test coverage now. Name Stmts Miss Cover cobras/ init .py 0 0 100% cobras/client/ init .py 0 0 100% cobras/client/client.py 89 46 48% cobras/client/connection.py 155 10 94% cobras/client/credentials.py 12 0 100% cobras/client/health_check.py 52 11 79% cobras/client/monitor.py 130 52 60% cobras/client/publish.py 14 0 100% cobras/common/ init .py 0 0 100% cobras/common/algorithm.py 4 1 75% cobras/common/apps_config.py 139 33 76% cobras/common/auth_hash.py 8 0 100% cobras/common/cobra_types.py 3 0 100% cobras/common/memoize.py 11 0 100% cobras/common/memory_debugger.py 70 10 86% cobras/common/memory_usage.py 13 3 77% cobras/common/task_cleanup.py 12 4 67% cobras/common/throttle.py 12 0 100% cobras/common/version.py 3 0 100% cobras/server/ init .py 0 0 100% cobras/server/app.py 143 16 89% cobras/server/connection_state.py 30 4 87% cobras/server/handlers/admin.py 58 32 45% cobras/server/handlers/auth.py 41 11 73% cobras/server/handlers/kv_store.py 96 20 79% cobras/server/handlers/pubsub.py 164 20 88% cobras/server/pipelined_publisher.py 40 14 65% cobras/server/pipelined_publishers.py 20 0 100% cobras/server/protocol.py 65 24 63% cobras/server/redis_connections.py 24 0 100% cobras/server/redis_subscriber.py 57 5 91% cobras/server/stats.py 97 8 92% cobras/server/stream_sql.py 129 11 91% TOTAL 1691 335 80% ## [1.6.6] - 2019-08-20 ### Changed - (server) upgrade sentry-sdk - change pre-commit ordering - cobra health failures are less noisy - make sure the health-check fails when redis is down - sort requirements file ... - more pre-commit fun - test client monitoring when redis is down - (linter) fix indentation - (doc) add note about some bad code - (wip/disabled) unittest / add code to check how monitoring works when redis is down - (server) when redis is down, and receiving a subscribe request, the server should send an error and it does not - (client) handle and throw explicit exception when the server sends a message without an id - read write test: add a test for when redis is down - test_utils makeRunner can take a redis config as an optional arg - remove unused parameter - update makefile + README ## [1.6.5] - 2019-08-20 ### Changed - (server+client) key value store: add a delete operation - (server) breaking protocol.py mega file into small ones ## [1.6.4] - 2019-08-20 ### Changed - (client) subscribe command: new --resume_from_last_position to start subscription where it was left of previously - (server) write operations sets stream max length to be 1 entry only to keep that stream small ### Fixed - format code with black + fix lint errors (flake8) / add linter to travis ## [1.6.3] - 2019-08-20 ### Fixed - (client) subscribe: when erroring while retrieving last position, the error message is lost ## [1.6.2] - 2019-08-20 ### Fixed - (client+server) read / write operations are handled gracefully when redis cannot be reached by the server ## [1.6.0] - 2019-08-19 ### New feature - (client) subscription can save and restore positions internally, so that no published events are missed in case a subscription trips up ### Fixed - (client) in the connection class, remove queues used for events that have already been received from the server ## [1.5.3] - 2019-08-19 - (client) reconnect wait time can be parameterized, still default to 1 second ## [1.5.2] - 2019-08-18 - (client) New admin command argument handling. Run `cobra admin --help` to see available admin actions. - (client) All command handle COBRA_PORT, so they will function properly in a docker environment, when hitting a local server with a non default port (!= 8765), through docker exec. - (server) Add admin command to disconnect just one connection - (server) Add admin command to retrieve all connection ids. ## [1.5.1] - 2019-08-18 ### Changed - cobras package is distributed as a wheel on PyPI. See [this](https://pythonwheels.com/). - Unittest can be run in parallel with py.xdist. On a 2014 macbook the runtime goes from 15 seconds down to 7 seconds. (venv) cobra$ py.test -n 10 tests ====================================== test session starts ====================================== platform darwin -- Python 3.7.2, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 rootdir: /Users/bsergeant/src/foss/cobra plugins: xdist-1.29.0, forked-1.0.2, cov-2.7.1 gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 ok / gw5 [37] / gw6 ok / gw7 ok / gw8 [37] / gw9 gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 ok / gw7 ok / gw8 [37] / gwgw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 [37] / gw7 ok / gw8 [37] / gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 [37] / gw7 [37] / gw8 [37] gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 [37] / gw7 [37] / gw8 [37] / gw9 [37] ..................................... [100%] =================================== 37 passed in 7.06 seconds =================================== (venv) cobra$ py.test ====================================== test session starts ====================================== platform darwin -- Python 3.7.2, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 rootdir: /Users/bsergeant/src/foss/cobra plugins: xdist-1.29.0, forked-1.0.2, cov-2.7.1 collected 37 items tests/test_app.py ... [ 8%] tests/test_apps_config.py ... [ 16%] tests/test_client_publish.py . [ 18%] tests/test_memory_debugger.py . [ 21%] tests/test_merge_monitor_events.py . [ 24%] tests/test_read_write.py . [ 27%] tests/test_redis_connections.py ... [ 35%] tests/test_redis_subscriber.py . [ 37%] tests/test_stream_sql.py ..................... [ 94%] tests/test_throttle.py . [ 97%] tests/test_validate_redis_position.py . [100%] ================================== 37 passed in 15.00 seconds ===================================``` ## [1.5.0] - 2019-08-16 ### Changed - (bavarde cli) fix history ## [1.4.13] - 2019-08-16 ### Changed - (bavarde cli) add --verbose flag which works like the cobra flag. ## [1.4.12] - 2019-08-16 ### Changed - Catch and display readable error when failing to start the server. Classic case is running it twice in two terminals, binding to the same port. 2019-08-16 22:34:27 CRITICAL Cannot start cobra server: [Errno 48] error while attempting to bind on address ('127.0.0.1', 8765): address already in use ## [1.4.11] - 2019-08-16 ### Changed - --verbose (short -v) can be passed in to all cobra commands, and almost all printing goes through the logging library. Logging format is simplified by removing hostname and username. 2019-08-16 21:57:56 INFO < {'action': 'rtm/publish/ok', 'id': 2, 'body': {}} ## [1.4.10] - 2019-08-16 ### Changed - (bavarde client) when cancelling with Ctrl-C if a connection was not established yet, do not try to terminate it ## [1.4.6] - 2019-08-16 ### Changed - (server) when running inside docker with a non default port (COBRA_PORT), health check fails as it is trying to use the default port (8765). Modified healt check to look at COBRA_PORT environment variable ## [1.4.5] - 2019-08-16 ### Changed - fix unittest (kv read/write) ## [1.4.4] - 2019-08-16 ### Changed - (server) handle more exception types when failing to connect to redis (such as cannot resolve DNS name) ## [1.4.3] - 2019-08-16 ### Changed - (server) Handle invalid COBRA_APPS_CONFIG_CONTENT values ## [1.4.2] - 2019-08-16 ### Changed - health check return non 0 exit code when a problem happens, instead of retrying to connect and succeed ## [1.4.1] - 2019-08-16 ### Changed - client: fix hang when an exception is thrown (disconnection with the server for example) inside the coroutine waiting for server data ## [1.4.0] - 2019-08-16 ### Changed - Fix very unflexible design in the client code, where the client heavily expected server responses in a specific order. New design is more flexible, and concurrent subscriptions or multiple publish can happens at the same time. - Server send a response to acknowledge publish messages. ## [1.3.4] - 2019-08-15 ### Changed - cobra can start if redis is down. Not being able to publish statistics is a non fatal error - COBRA_APPS_CONFIG_CONTENT contains data that is gziped first before being encoded with base64. You can generate that blob with `gzip -c ~/.cobra.yaml | base64` on macOS, or `gzip -c ~/.cobra.yaml | openssl base64` if you have openssl installed ; you'll need to join all the blobs so that they are all on the same line in that case. ## [1.3.3] - 2019-08-15 ### Changed - cobra run can use an environment variable, COBRA_APPS_CONFIG_CONTENT, to specify the content of the configuration file ## [1.3.0] - 2019-08-15 ### Changed - Server has a simple key value store, internally storing data in stream (at the 'tip' of it). A value can be retrieved at a certain position. - New `cobra read` and `cobra write` commands, to work with the Key Value Store ## [1.2.8] - 2019-08-14 ### Changed - `cobra publish` command broke because of refactoring - use new exceptions types from websockets 8.0.2 to get better logging about connection termination ## [1.2.7] - 2019-08-13 ### Changed - update to websockets 8.0.2 - unittest does not run with warnings ## [1.2.6] - 2019-08-12 ### Changed - bavarde: colorize output - client API changed, new connection class (wip) - client subscriber API changed, takes a parsed json message + position ## [1.2.5] - 2019-08-12 ### Changed - bavarde client: first prompt line is not displayed with a regular prompt ## [1.2.4] - 2019-08-12 ### Changed - bavarde client: exiting with Ctrl-C cancel the subscription. Get rid of the message: `Task was destroyed but it is pending!` - bavarde client: first prompt line is not displayed with a regular prompt ## [1.2.3] - 2019-08-10 ### Changed - bavarde client displays a time indication [18:43:06] bsergeant> sdc [18:43:06] bsergeant> adc [18:45:17] bsergeant> dddddddddddd ``` [1.2.2] - 2019-08-09 Changed cobra server will reject invalid position when subscribing instead of ignoring it, which seems to trigger a hang when calling XREAD on a stream (needs to investigate) [1.2.0] - 2019-08-09 Changed Add example code for a chat command line interactive client named bavarde. The chat connects to a public cobra server. Many features from a decent chat are missing, Most of the interactive chat code was taken from the websockets library. [1.1.1] - 2019-08-07 Changed Use a more elegant way to retrieve cobras version number, with pkg_resources module. (health-check client) handle publish that triggers a server error (when redis is misconfigured) [1.1.0] - 2019-08-03 Changed Implement permissions, to give certain roles publish or subscribe only permission. This can be used to add security and restrict a client in the wild to only publish its own data to a channel, but not to be able to look at traffic from different apps by subscribing on the same channel Improve error reporting in the health check command Make unsubscribing in the server code more robust, when passing in bogus data Add history support. Each published message has an id called a position. That id can be used when subscribing to retrieve messages that a subscriber would have missed if it was down while that message was published. Add read command (client + server) to retrieve one element from history. A write and a delete command are comming. Add --hide_roles, --hide_nodes and --system options to the monitor command, to deal with displaying info about cobra deployments with lots of nodes or roles. --system info does not display publish/subscribe statistics by nodes but instead system info such as connection count and numbers of asyncio tasks. [1.0.0] - 2019-07-31 Changed Redis Streams instead of Redis PubSub are used internally to dispatch messages. History is not used at this point, so the change is really a pure swap without any added features, but we are ready for taking advantage of history. [0.0.196] - 2019-07-26 Changed Initial release","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All changes to this project will be documented in this file.","title":"Changelog"},{"location":"CHANGELOG/#261-2019-12-05","text":"(server) bump sentry_sdk dependency to 0.13.5 + set release and environment while initializing the sentry sdk","title":"[2.6.1] - 2019-12-05"},{"location":"CHANGELOG/#260-2019-12-05","text":"(server) check that redis nodes are reachable on startup, with a timeout. $ brew services stop redis Stopping `redis`... (might take a while) ==> Successfully stopped `redis` (label: homebrew.mxcl.redis) $ cobra run runServer {'host': '127.0.0.1', 'port': '8765', 'redis_urls': 'redis://localhost;redis://localhost', 'redis_password': None, 'apps_config_path': '/Users/bsergeant/.cobra.yaml', 'apps_config_path_content': None, 'debug_memory': False, 'debug_memory_no_tracemalloc': False, 'plugins': None, 'sentry': False, 'sentry_url': None, 'prod': False, 'no_stats': False, 'max_subscriptions': -1, 'idle_timeout': 300, 'disable_redis_startup_probing': False, 'redis_startup_probing_timeout': 30} Checking redis://localhost .................................................................................................................................................... 2019-12-05 22:17:23 CRITICAL Cannot start cobra server: Multiple exceptions: [Errno 61] Connect call failed ('::1', 6379, 0, 0), [Errno 61] Connect call failed ('127.0.0.1', 6379)","title":"[2.6.0] - 2019-12-05"},{"location":"CHANGELOG/#255-2019-12-05","text":"(client) add --tidy to the monitor subcommand to only print generic info","title":"[2.5.5] - 2019-12-05"},{"location":"CHANGELOG/#254-2019-12-04","text":"(server) rtm/publish handler: ignore empty channels (which gets serialized as \"None\")","title":"[2.5.4] - 2019-12-04"},{"location":"CHANGELOG/#253-2019-12-04","text":"(client) cobra health command parameters consistent with other commands (sdk) publish cobras package to npm","title":"[2.5.3] - 2019-12-04"},{"location":"CHANGELOG/#252-2019-12-02","text":"(server) improve redis subscription logging","title":"[2.5.2] - 2019-12-02"},{"location":"CHANGELOG/#251-2019-12-02","text":"(server + client) subscribe interface changed to receive multiple messages The --batch_size option can be specified to the subscribe sub-command to request messages to be delivered in batch. This is convenient when a subscriber expects lots of messages to be received, as it saves the various overhead of sending smaller individual messages. Notice how all msg count received are a multiple of 50 in the example below, where we request a batch size of 50 messages. ~ $ cobra subscribe --endpoint wss://example.com --appkey XXXX --rolename _sub --rolesecret YYYYYYY --channel channel_name \\ --disable_debug_memory \\ --batch_size 50 position None #messages 0 msg/s 0 position 1575316403409-2 #messages 2350 msg/s 2350 position 1575316404404-4 #messages 4550 msg/s 2200 position 1575316405414-10 #messages 6800 msg/s 2250 position 1575316406418-0 #messages 9250 msg/s 2450 position 1575316407403-8 #messages 11600 msg/s 2350 position 1575316408419-5 #messages 13900 msg/s 2300 position 1575316409394-10 #messages 16250 msg/s 2350 position 1575316410416-7 #messages 18650 msg/s 2400 ``` ## [2.5.0] - 2019-12-01 * (client) subscribe interface changed to receive multiple messages (only one at a time supported so far) ## [2.4.2] - 2019-11-19 * (server) HTTP GET / display some informations about cobra ## [2.4.1] - 2019-11-19 * make the server more resilient when dealing with stale redis connections ## [2.4.0] - 2019-11-18 * add per channel statistics for publish and subscribe ## [2.3.7] - 2019-11-13 * (deps) bump websockets lib dependency to 8.1 ## [2.3.6] - 2019-11-12 * (client) async method call needs to be awaited ## [2.3.5] - 2019-11-12 * (build) tweak requirements file, to mark sentry as a loose dependency ## [2.3.4] - 2019-11-12 * (common) Write memory statistics on stderr instead of stdout ## [2.3.3] - unreleased ## [2.3.2] - 2019-10-18 * (client) In connection code, bring back slower code which does not leak and is exception safe ## [2.3.1] - 2019-10-18 * All tasks are given an exception handler to log errors into sentry ## [2.3.0] - 2019-10-18 * Switch to rapidjson from standard json as it is noticeably faster, the only downside is that it takes longer to install / make Docker containers ## [2.2.5] - 2019-10-17 * Bump sentry_sdk dependency ## [2.2.4] - 2019-10-17 * Fix performance problem when saving the last position received when subscribing (--resume_from_last_position) ## [2.2.3] - 2019-10-17 * Docker file second layer still reference an old Python. Default read/write subcommands channel clashes with the default publish/subcribe, so make it unique. Add --repeat option to write subcommand to indefinitely write. ## [2.2.2] - 2019-10-16 * Bump to python 3.8.0 proper. getVersion utility can take a module name. ## [2.2.1] - 2019-10-16 * Fix a memory leak in the client connection class ## [2.2.0] - 2019-10-15 * Add a --debug_memory_no_tracemalloc option to cobra run to have a 'slim' memory debugging mode. ## [2.1.9] - 2019-10-15 * bump tabulate to 0.8.5 ## [2.1.8] - 2019-10-08 * bump sentry_sdk to 0.12.3 ## [2.1.7] - 2019-10-02 * redis connections from the pipelined publishers are closed when terminating the app (mostly useful to get rid of python 3.8rc1 warnings when running the unittest) ## [2.1.6] - 2019-10-01 * display all http headers when catching zlib decompression error explicitly and logging an error ## [2.1.5] - 2019-10-01 * catch zlib decompression error explicitly and log an error including the connection id ## [2.1.4] - 2019-09-30 * sentry integration / report the user agent properly using the current sentry Hub (see https://github.com/getsentry/sentry-python/issues/483) ## [2.1.3] - 2019-09-30 * redis subscription: detect max number of clients reached error and fail rtm/subscribe commands ## [2.1.2] - 2019-09-27 * fix redis connection leak in rtm/delete ## [2.1.0] - 2019-09-25 * bump aio-redis dependency to 1.3.0 ## [2.0.0] - 2019-09-19 * cobra works with python3.8 (beta4 at this point) ## [1.9.0] - 2019-09-18 * server / LIKE expression follows more closely the SQL standard, using globbing/fnmatch to evaluate expressions. LIKE can be used to compute startswith and endswith queries for strings. % (match all) and _ (match one) characters are supported, and mapped to * and ? fnmatch globbing special characters. ## [1.8.2] - 2019-09-17 * server / add a channel_max_length apps config parameter that limits how many messages can be retained in a single channel. Still default to a 1000 messages. The parameter is a global, top level yaml config for now. It is likely that we will make it a per appkey settings. In the example below we set it to 100. This parameter is helpful if you are trying to use cobra to transfer large messages. $ head ~/.cobra.yaml batch_publish_size: 50 channel_max_length: 100 ## [1.8.1] - 2019-09-17 * server / user-agent recorded as a sentry context info is a python 3.7 Context Variable * server / log a warning instead of an error when a connection is made with an invalid appkey ## [1.8.0] - 2019-09-17 * server / record user-agent as a sentry context info ## [1.7.9] - 2019-09-17 * server / log an error when a connection is made with an invalid appkey ## [1.7.8] - 2019-09-11 * server / return metadata about a stream (existence and length) when subscribing to a channel (in the body response) ## [1.7.7] - 2019-09-11 * bump sentry_sdk dep to 0.11.2 ## [1.7.6] - 2019-09-11 * server / connection state holds a userAgent and has a __repr__ method, this should work with sentry errors to identify bad clients ## [1.7.5] - 2019-09-11 * server / connection id is 12 byte long, instead of 8. This might help with some rare collisions. ## [1.7.4] - 2019-09-10 * server / make disk logging work on Windows by using tempfile.gettempdir() instead of /tmp/ ## [1.7.3] - 2019-09-09 * client / when closing a connection, make sure to unsubscribe all subscriptions ## [1.7.1] - 2019-08-29 ### Changed * bump click version ## [1.7.0] - 2019-08-28 ### Changed * rtm/delete delete a stream, instead of writing a null entry in it * health check delete temp channel/streams + test read/write/delete ## [1.6.12] - 2019-08-28 ### Changed * Add optional http test in health-check, with --http_extra_check ## [1.6.11] - 2019-08-28 ### Fixed * Fixed a couple of pylint warnings * Stop depending on ujson ## [1.6.10] - 2019-08-24 ### Changed * Upgrade uvloop dependency to 0.13.0 to hopefully solve [Fatal error on transport TCPTransport](https://github.com/MagicStack/uvloop/issues/244) kind of errors. * Dockerfile uses Python 3.7.4 ## [1.6.9] - 2019-08-23 ### Fixed Missing __init__.py file required to have a the handlers folder loaded. ## [1.6.8] - 2019-08-23 ### Changed - (client) New --summary option for cobra publish, usually used to see how many messages can be sent to a server per second (venv) cobra$ cobra publish --url 'ws://jeanserge.com/v2?appkey=_health' --repeat --delay 0.001 --secret A5a3BdEfbc6Df5AAFFcadE7F9Dd7F17E --role health Processing 1 items 1 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds 19 per seconds ^C Aborted! ## [1.6.7] - 2019-08-21 ### Changed - More unittest to test failures in pubsub and health-checks. Above 80% test coverage now.","title":"[2.5.1] - 2019-12-02"},{"location":"CHANGELOG/#name-stmts-miss-cover","text":"cobras/ init .py 0 0 100% cobras/client/ init .py 0 0 100% cobras/client/client.py 89 46 48% cobras/client/connection.py 155 10 94% cobras/client/credentials.py 12 0 100% cobras/client/health_check.py 52 11 79% cobras/client/monitor.py 130 52 60% cobras/client/publish.py 14 0 100% cobras/common/ init .py 0 0 100% cobras/common/algorithm.py 4 1 75% cobras/common/apps_config.py 139 33 76% cobras/common/auth_hash.py 8 0 100% cobras/common/cobra_types.py 3 0 100% cobras/common/memoize.py 11 0 100% cobras/common/memory_debugger.py 70 10 86% cobras/common/memory_usage.py 13 3 77% cobras/common/task_cleanup.py 12 4 67% cobras/common/throttle.py 12 0 100% cobras/common/version.py 3 0 100% cobras/server/ init .py 0 0 100% cobras/server/app.py 143 16 89% cobras/server/connection_state.py 30 4 87% cobras/server/handlers/admin.py 58 32 45% cobras/server/handlers/auth.py 41 11 73% cobras/server/handlers/kv_store.py 96 20 79% cobras/server/handlers/pubsub.py 164 20 88% cobras/server/pipelined_publisher.py 40 14 65% cobras/server/pipelined_publishers.py 20 0 100% cobras/server/protocol.py 65 24 63% cobras/server/redis_connections.py 24 0 100% cobras/server/redis_subscriber.py 57 5 91% cobras/server/stats.py 97 8 92% cobras/server/stream_sql.py 129 11 91% TOTAL 1691 335 80% ## [1.6.6] - 2019-08-20 ### Changed - (server) upgrade sentry-sdk - change pre-commit ordering - cobra health failures are less noisy - make sure the health-check fails when redis is down - sort requirements file ... - more pre-commit fun - test client monitoring when redis is down - (linter) fix indentation - (doc) add note about some bad code - (wip/disabled) unittest / add code to check how monitoring works when redis is down - (server) when redis is down, and receiving a subscribe request, the server should send an error and it does not - (client) handle and throw explicit exception when the server sends a message without an id - read write test: add a test for when redis is down - test_utils makeRunner can take a redis config as an optional arg - remove unused parameter - update makefile + README ## [1.6.5] - 2019-08-20 ### Changed - (server+client) key value store: add a delete operation - (server) breaking protocol.py mega file into small ones ## [1.6.4] - 2019-08-20 ### Changed - (client) subscribe command: new --resume_from_last_position to start subscription where it was left of previously - (server) write operations sets stream max length to be 1 entry only to keep that stream small ### Fixed - format code with black + fix lint errors (flake8) / add linter to travis ## [1.6.3] - 2019-08-20 ### Fixed - (client) subscribe: when erroring while retrieving last position, the error message is lost ## [1.6.2] - 2019-08-20 ### Fixed - (client+server) read / write operations are handled gracefully when redis cannot be reached by the server ## [1.6.0] - 2019-08-19 ### New feature - (client) subscription can save and restore positions internally, so that no published events are missed in case a subscription trips up ### Fixed - (client) in the connection class, remove queues used for events that have already been received from the server ## [1.5.3] - 2019-08-19 - (client) reconnect wait time can be parameterized, still default to 1 second ## [1.5.2] - 2019-08-18 - (client) New admin command argument handling. Run `cobra admin --help` to see available admin actions. - (client) All command handle COBRA_PORT, so they will function properly in a docker environment, when hitting a local server with a non default port (!= 8765), through docker exec. - (server) Add admin command to disconnect just one connection - (server) Add admin command to retrieve all connection ids. ## [1.5.1] - 2019-08-18 ### Changed - cobras package is distributed as a wheel on PyPI. See [this](https://pythonwheels.com/). - Unittest can be run in parallel with py.xdist. On a 2014 macbook the runtime goes from 15 seconds down to 7 seconds. (venv) cobra$ py.test -n 10 tests ====================================== test session starts ====================================== platform darwin -- Python 3.7.2, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 rootdir: /Users/bsergeant/src/foss/cobra plugins: xdist-1.29.0, forked-1.0.2, cov-2.7.1 gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 ok / gw5 [37] / gw6 ok / gw7 ok / gw8 [37] / gw9 gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 ok / gw7 ok / gw8 [37] / gwgw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 [37] / gw7 ok / gw8 [37] / gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 [37] / gw7 [37] / gw8 [37] gw0 [37] / gw1 [37] / gw2 [37] / gw3 [37] / gw4 [37] / gw5 [37] / gw6 [37] / gw7 [37] / gw8 [37] / gw9 [37] ..................................... [100%] =================================== 37 passed in 7.06 seconds =================================== (venv) cobra$ py.test ====================================== test session starts ====================================== platform darwin -- Python 3.7.2, pytest-5.0.1, py-1.8.0, pluggy-0.12.0 rootdir: /Users/bsergeant/src/foss/cobra plugins: xdist-1.29.0, forked-1.0.2, cov-2.7.1 collected 37 items tests/test_app.py ... [ 8%] tests/test_apps_config.py ... [ 16%] tests/test_client_publish.py . [ 18%] tests/test_memory_debugger.py . [ 21%] tests/test_merge_monitor_events.py . [ 24%] tests/test_read_write.py . [ 27%] tests/test_redis_connections.py ... [ 35%] tests/test_redis_subscriber.py . [ 37%] tests/test_stream_sql.py ..................... [ 94%] tests/test_throttle.py . [ 97%] tests/test_validate_redis_position.py . [100%] ================================== 37 passed in 15.00 seconds ===================================``` ## [1.5.0] - 2019-08-16 ### Changed - (bavarde cli) fix history ## [1.4.13] - 2019-08-16 ### Changed - (bavarde cli) add --verbose flag which works like the cobra flag. ## [1.4.12] - 2019-08-16 ### Changed - Catch and display readable error when failing to start the server. Classic case is running it twice in two terminals, binding to the same port. 2019-08-16 22:34:27 CRITICAL Cannot start cobra server: [Errno 48] error while attempting to bind on address ('127.0.0.1', 8765): address already in use ## [1.4.11] - 2019-08-16 ### Changed - --verbose (short -v) can be passed in to all cobra commands, and almost all printing goes through the logging library. Logging format is simplified by removing hostname and username. 2019-08-16 21:57:56 INFO < {'action': 'rtm/publish/ok', 'id': 2, 'body': {}} ## [1.4.10] - 2019-08-16 ### Changed - (bavarde client) when cancelling with Ctrl-C if a connection was not established yet, do not try to terminate it ## [1.4.6] - 2019-08-16 ### Changed - (server) when running inside docker with a non default port (COBRA_PORT), health check fails as it is trying to use the default port (8765). Modified healt check to look at COBRA_PORT environment variable ## [1.4.5] - 2019-08-16 ### Changed - fix unittest (kv read/write) ## [1.4.4] - 2019-08-16 ### Changed - (server) handle more exception types when failing to connect to redis (such as cannot resolve DNS name) ## [1.4.3] - 2019-08-16 ### Changed - (server) Handle invalid COBRA_APPS_CONFIG_CONTENT values ## [1.4.2] - 2019-08-16 ### Changed - health check return non 0 exit code when a problem happens, instead of retrying to connect and succeed ## [1.4.1] - 2019-08-16 ### Changed - client: fix hang when an exception is thrown (disconnection with the server for example) inside the coroutine waiting for server data ## [1.4.0] - 2019-08-16 ### Changed - Fix very unflexible design in the client code, where the client heavily expected server responses in a specific order. New design is more flexible, and concurrent subscriptions or multiple publish can happens at the same time. - Server send a response to acknowledge publish messages. ## [1.3.4] - 2019-08-15 ### Changed - cobra can start if redis is down. Not being able to publish statistics is a non fatal error - COBRA_APPS_CONFIG_CONTENT contains data that is gziped first before being encoded with base64. You can generate that blob with `gzip -c ~/.cobra.yaml | base64` on macOS, or `gzip -c ~/.cobra.yaml | openssl base64` if you have openssl installed ; you'll need to join all the blobs so that they are all on the same line in that case. ## [1.3.3] - 2019-08-15 ### Changed - cobra run can use an environment variable, COBRA_APPS_CONFIG_CONTENT, to specify the content of the configuration file ## [1.3.0] - 2019-08-15 ### Changed - Server has a simple key value store, internally storing data in stream (at the 'tip' of it). A value can be retrieved at a certain position. - New `cobra read` and `cobra write` commands, to work with the Key Value Store ## [1.2.8] - 2019-08-14 ### Changed - `cobra publish` command broke because of refactoring - use new exceptions types from websockets 8.0.2 to get better logging about connection termination ## [1.2.7] - 2019-08-13 ### Changed - update to websockets 8.0.2 - unittest does not run with warnings ## [1.2.6] - 2019-08-12 ### Changed - bavarde: colorize output - client API changed, new connection class (wip) - client subscriber API changed, takes a parsed json message + position ## [1.2.5] - 2019-08-12 ### Changed - bavarde client: first prompt line is not displayed with a regular prompt ## [1.2.4] - 2019-08-12 ### Changed - bavarde client: exiting with Ctrl-C cancel the subscription. Get rid of the message: `Task was destroyed but it is pending!` - bavarde client: first prompt line is not displayed with a regular prompt ## [1.2.3] - 2019-08-10 ### Changed - bavarde client displays a time indication [18:43:06] bsergeant> sdc [18:43:06] bsergeant> adc [18:45:17] bsergeant> dddddddddddd ```","title":"Name                                    Stmts   Miss  Cover"},{"location":"CHANGELOG/#122-2019-08-09","text":"","title":"[1.2.2] - 2019-08-09"},{"location":"CHANGELOG/#changed","text":"cobra server will reject invalid position when subscribing instead of ignoring it, which seems to trigger a hang when calling XREAD on a stream (needs to investigate)","title":"Changed"},{"location":"CHANGELOG/#120-2019-08-09","text":"","title":"[1.2.0] - 2019-08-09"},{"location":"CHANGELOG/#changed_1","text":"Add example code for a chat command line interactive client named bavarde. The chat connects to a public cobra server. Many features from a decent chat are missing, Most of the interactive chat code was taken from the websockets library.","title":"Changed"},{"location":"CHANGELOG/#111-2019-08-07","text":"","title":"[1.1.1] - 2019-08-07"},{"location":"CHANGELOG/#changed_2","text":"Use a more elegant way to retrieve cobras version number, with pkg_resources module. (health-check client) handle publish that triggers a server error (when redis is misconfigured)","title":"Changed"},{"location":"CHANGELOG/#110-2019-08-03","text":"","title":"[1.1.0] - 2019-08-03"},{"location":"CHANGELOG/#changed_3","text":"Implement permissions, to give certain roles publish or subscribe only permission. This can be used to add security and restrict a client in the wild to only publish its own data to a channel, but not to be able to look at traffic from different apps by subscribing on the same channel Improve error reporting in the health check command Make unsubscribing in the server code more robust, when passing in bogus data Add history support. Each published message has an id called a position. That id can be used when subscribing to retrieve messages that a subscriber would have missed if it was down while that message was published. Add read command (client + server) to retrieve one element from history. A write and a delete command are comming. Add --hide_roles, --hide_nodes and --system options to the monitor command, to deal with displaying info about cobra deployments with lots of nodes or roles. --system info does not display publish/subscribe statistics by nodes but instead system info such as connection count and numbers of asyncio tasks.","title":"Changed"},{"location":"CHANGELOG/#100-2019-07-31","text":"","title":"[1.0.0] - 2019-07-31"},{"location":"CHANGELOG/#changed_4","text":"Redis Streams instead of Redis PubSub are used internally to dispatch messages. History is not used at this point, so the change is really a pure swap without any added features, but we are ready for taking advantage of history.","title":"Changed"},{"location":"CHANGELOG/#00196-2019-07-26","text":"","title":"[0.0.196] - 2019-07-26"},{"location":"CHANGELOG/#changed_5","text":"Initial release","title":"Changed"},{"location":"api/","text":"Overview The RTM protocol is our wire protocol, which enables direct two-way communication between a client and RTM. Clients communicate with RTM by establishing a secure WebSocket connection and exchanging JSON- or CBOR-encoded units. RTM implements the publish-subscribe pattern where users publish messages to a channel and all subscribers to that channel receive those messages. The RTM API defines the structure, rules and semantics for exchanging the JSON objects. We call these JSON objects Protocol Data Units (PDUs). A PDU can carry a request to RTM to perform a particular action (such as to publish a message), its response from RTM, or an unsolicited message, such as subscription data. Message order guarantees RTM forwards published messages to the subscribers in the same order as it received them. The order of messages between different publishers is not guaranteed. All subscribers will receive the published messages in the same order. Protocol Data Unit (PDU) Definition A PDU is a unit, formatted in JSON or CBOR, with a specific structure enabling meaningful communication between RTM and clients. Each PDU is encoded into a single WebSocket frame. RTM supports UTF-8. PDU encoding We use custom self-explanatory \"mini schema\" to define the format of JSON PDUs. It uses JSON syntax to describe fields, followed by their type or placeholder values (which in turned are defined the same way). Fields order does not matter. See [41]Mini-schema Reference for more details. The following mini schema defines the structure of a PDU. Note that this structure holds for all PDUs in RTM API. { \"action\": string, \"id\": string | integer OPTIONAL, \"body\": object } JSON PDUs JSON PDUs are JSON objects. In languages other than JavaScript, use a JSON API to convert native objects to a canonical JSON form. WebSocket for RTM Endpoint The WebSocket connection string for RTM has the syntax: <endpoint>/<rtm_version>?appkey=<appkey> : Endpoint string, for example wss://example.com : Current version of RTM, for example v2. The current version is listed at the beginning of the RTM API documentation : Appkey from ~/.cobra.yaml For example: wss://example.com/v2?appkey=46832Af7f7cba8df8Fa2Bd5CE8B7D99E PDU types A PDU can represent any of the following units of communication: * A request to RTM. A request to perform an action, for example, to publish a message. * A response from RTM. The response to a client request. * Unsolicited subscription messages from RTM. Messages as they have been published to the channel for simple subscriptions, or resulting messages for subscriptions with views. * An unsolicited error or information updates. Channel-specific informational or error messages, or system error messages, sent by RTM to the client. PDU size User generated \"payload\" size is unlimited. PDU fields action field The action field specifies the purpose of a PDU and determines the content of the body. The action field consists of up to three components separated by forward slash: / / . The following table explains the meaning of each component, as well as the rule for parsing it out from the full action string value: Action component Meaning Parsing rules service Name of the service responsible for handling incoming requests or sending responses and unsolicited PDUs. The first part of the action string up to the first backslash character `/'. operation Operation the client wants the service to perform. After the first backslash character \"/\" up to the outcome or end of the string. Note that it may contain backslashes as part of the operation. outcome Represents the result of the request or the type of information provided to the client. Present only in responses and unsolicited PDUs. The part after the last backslash \"/\". id field The id field in a request PDU instructs RTM to send a response and enables a client to match a response to a request. If the id field is not present in a request, RTM does not acknowledge it: no response will be sent to a client, regardless of the outcome. Note that id field and its semantics applies to every PDU in the RTM protocol. The id field can be an integer or a string. Even though specifying id field in a request is optional, only a few cases benefit from omitting it (e.g. high throughput publishing); some operation cannot be completed without id at all (e.g. authentication). Clients should specify id in a request, unless client logic identified a concrete motivation not to do so, for a specific use case. Use the following rules and guidelines with the id field: Rule/Guideline Description Include id field to get a response from RTM In most cases, there is no significant traffic savings from omitting the id but by doing so, client forfeits an opportunity to detect failing requests (error outcome). Avoid reusing id value in different requests RTM does not enforce uniqueness on the id field. Two requests with the same id are treated as two separate requests by RTM. body field The body field's content is specific to the PDU's action. The structure and semantics of the body field's content must be followed for each action field type. See the definitions of the specific PDU types. Channels Channels are named streams of messages. A channel is unique per Dev Portal project. If two projects have channels with the same name, RTM treats them as separate channels: they have their own content, history, settings, permissions, etc. Subscription Subscriptions are clients' interest in messages published to a channel, accepted and served by RTM. In the simplest case, a subscription establishes a client's interest in all messages as they arrive in a channel. Clients may also request a subscription to include past messages (see history and position). In more involved cases, message data can be filtered or/and transformed (see [43]Views). Position A position is a message offset relative to other messages in the channel. It uniquely identifies the location of the message in the channel and may refer to an expired (no longer stored), available (stored, retrievable), or future (not yet occupied location) message. The next channel position is the first available unoccupied position in a channel. The next published message to arrive is placed at this position. The position field can be used to read a particular message from a channel or to subscribe from a specific position, typically in order to avoid skipping messages when re-subscribing. Implicit channel creation and deletion Channel instances are automatically created by RTM on demand: upon the first subscribe or publish request to a specified channel name, RTM creates a corresponding channel instance. RTM automatically garbage collects channels when it is safe to do so (channel is empty and no one has been accessing it for some time). Channel instance creation and deletion should not be confused with managing channel bookkeeping in Dev Portal, such as setting permissions or history for specific channel names or namespaces. Channel history In addition to forwarding published messages to all subscribers, RTM also stores all messages for at least 1 minute. Additionally, longer storage is available with channel history: users can configure how many messages should be stored for a longer period of time for a given channel. History settings are configured in Dev Portal and default to one message for 6 hours. A subscription to a channel can be requested starting at a historical message; similarly read operation can retrieve messages published in the past. Channel names Channel names are case sensitive. Channel names starting with character `$' are reserved by RTM. Publish PDU Messages can be published to a channel by sending a Publish PDU request to RTM. The following specification shows the publish request and response PDUs: Request { \"action\":\"rtm/publish\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":ChannelName, \"message\":Message } } Response (OK) { \"action\":\"rtm/publish/ok\", \"id\": RequestId, \"body\":{ \"position\":Position } } Response (error) { \"action\":\"rtm/publish/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } Field Type Description ChannelName string The name of the channel to publish to. Message value The message to publish to the channel. Position string The channel location of the published message. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Subscribe PDU A client subscribes to a channel by sending a request Subscribe PDU to RTM. Position By default, a new subscription starts at the next channel position (from the next published message, see position in [51]Channels). That is, no previously published (historic) messages are returned. A client may start a subscription at an earlier (historic) message by specifying the position in the subscribe request PDU. subscription_id A subscription is identified by the subscription_id field. Multiple subscriptions can be made to the same channel, as long as different subscription id's are used. For a subscription without a view (default), the subscription_id must be equal to the channel name, and is optional. For a subscription with a view, the subscription_id field is required and the channel field is optional (the channel name must match what is specified in the filter (view) field). Subscribe without streamview (no filter field) Request { \"action\":\"rtm/subscribe\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":ChannelName, \"subscription_id\":SubId OPTIONAL, \"force\":Force OPTIONAL, \"fast_forward\":FastForward OPTIONAL, \"position\":Position OPTIONAL, \"history\":{ \"count\":Count OPTIONAL, \"age\":Age OPTIONAL } OPTIONAL } } Response (ok) { \"action\":\"rtm/subscribe/ok\", \"id\":RequestId \"body\":{ \"position\":Position, \"subscription_id\":SubId } } Response (error) { \"action\":\"rtm/subscribe/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason OPTIONAL, \"subscription_id\":SubId } } Subscribe with streamview (filter field) Request { \"action\":\"rtm/subscribe\", \"id\":RequestId OPTIONAL, \"body\":{ \"filter\":SQL, \"subscription_id\":SubId, \"force\":Force OPTIONAL, \"fast_forward\":FastForward OPTIONAL, \"period\":Period OPTIONAL, \"position\":Position OPTIONAL, \"history\":{ \"count\":Count OPTIONAL, \"age\":Age OPTIONAL } OPTIONAL } } Response (ok) { \"action\":\"rtm/subscribe/ok\", \"id\":RequestId, \"body\":{ \"position\":Position, \"subscription_id\":SubId } } Response (error) { \"action\":\"rtm/subscribe/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason OPTIONAL, \"subscription_id\":SubId } } Field Type Description ChannelName string The name of the channel to subscribe to. SubId string Either a channel name or a unique client-generated identifier for the subscription (when applicable) Position string Channel location to start the subscription at. Default is the next channel position. SQL string SQL statement to run on messages before sending them to the client. See Views. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. RequestId int or string See id field in PDU section. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Subscribe-specific errors error value Meaning already_subscribed You requested a new subscription with subscription_id set to an active subscription id, and you didn't specify \"force\" : true. expired_position RTM expired the message at the position you specified in position. The message is no longer available. invalid_filter (for a streamview subscription only): The stream SQL you specified in filter is invalid. subscription_quota_exceeded You tried to add a subscription or streamview, but you exceeded the quota for the number of subscriptions or streamviews per project. The \"action\" field is always \"action\":\"rtm/subscribe/error\". out_of_sync and fast_forward RTM sends subscription messages to the client as fast as the physical network link to the client allows it. If the rate of incoming (published) messages is higher than the outgoing rate (rate at which messages are delivered to a particular client subscription), we say that a client subscription is falling behind. If this situation persists, undelivered messages accumulate on the RTM side and eventually RTM expires (deletes) them. By default, messages are deleted after 60 seconds and the last message in a channel - after 6h. We call this situation out_of_sync: messages stream continuity cannot be sustained for a subscriber; message drop is inevitable. Subscriber can change this behavior by setting the fast_forward field to true in the request Subscribe PDU. In this case, RTM \"fast-forwards\" the client to the oldest not yet deleted message, instead of forcing unsubscription, and sends an info Subscription PDU. Updating a subscription filter and period fields can be changed on-the-fly for a pre-existing active subscription: by sending a Subscribe PDU with the force field set to true. Without \"force\":true, RTM responds with an already_subscribed error and does not update the current subscription. Subscription PDUs (unsolicited) RTM sends subscription data (channel messages) or subscription related status (info or error) using subscription PDUs. Subscription PDU can be: * data. A subscription data PDU delivers channel messages (possibly filtered and transformed messages in case of a viewed subscription). Note that a single subscription data PDU can contain multiple messages grouped in the array messages field (for optimization purposes). * info. A subscription Info PDU contains information about a subscription, which includes the type of info and the reason why RTM sent it. For a fast_forward info, it also includes the count of skipped messages due to RTM fast-forwarding the subscription. * error. A subscription error PDU notifies of subscription termination (forceful unsubscription) due to a subscription-related error. For example, if a client subscription falls behind and fast-forward has not been enabled, RTM sends an out_of_sync error and unsubscribes the client (see out_of_sync in [60]Subscribe PDU section). Subscription data { \"action\":\"rtm/subscription/data\", \"body\":{ \"position\":Position, \"messages\":[Message]*, \"subscription_id\":SubId } } Subscription info { \"action\":\"rtm/subscription/info\", \"body\":{ \"info\":InfoType, \"reason\":InfoReason, \"position\":Position, \"subscription_id:SubId, \"missed_message_count\":Count OPTIONAL } } Subscription error { \"action\":\"rtm/subscription/error\", \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason, \"position\":Position, \"subscription_id\":SubId, \"missed_message_count\":Count OPTIONAL } } Field Type Description Position string Provided to enable clients to resubscribe preserving stream continuity (in the event of a disconnect). Message value A channel message (as it was published, or - when applicable - a message result according to the subscription view) SubId string Id for the subscription for which the PDU was sent. InfoType string Information type. See Service-Specific Info Messages. InfoReason text In the sections following this table, see \"Unsolicited subscribe info messages\". Count int Number of skipped messages in the channel. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See [62]Error Reference. Unsolicited subscribe errors RTM may return one of these errors for an active subscription: error value Meaning out_of_sync The message position for the subscription is pointing to an expired message, and your subscribe PDU didn't specify \"fast_forward\" : true. RTM unsubscribes you, and it may drop your connection. expired_position Your subscribe PDU specified the \"position\" field, but its value points to an expired message. The \"action\" field is always \"action\":\"rtm/subscription/error\". Unsolicited subscribe info messages RTM may return this info message for an active subscription: info value Meaning fast_forward Because your subscribe PDU specified \"fast_forward\" : true, RTM performed a fast forward in response to an out of sync condition. You receive this info PDU in addition to an error PDU with error set to \"expired_position\". The \"action\" field is always \"action\":\"rtm/subscription/info\". Unsubscribe PDU A subscriber requests to terminate its subscription by sending an Unsubscribe PDU request to RTM. In case a client endpoint has multiple subscriptions to the same channel, it must send a PDU for each subscription it wants to end. Request { \"action\":\"rtm/unsubscribe\", \"id\":RequestId OPTIONAL, \"body\":{ \"subscription_id\":SubId } } Response (ok) { \"action\":\"rtm/unsubscribe/ok\", \"id\":RequestId, \"body\":{ \"position\":Position, \"subscription_id\":SubId } } Response (error) { \"action\":\"rtm/unsubscribe/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason, \"subscription_id\":SubId OPTIONAL } } Field Type Description SubId string Id of the subscription that you want to cancel. Position string RTM response includes current location in the channel message stream at the time unsubscribe operation has completed. Enables a client to resubscribe to the channel from the position where it unsubscribed ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See [64]Error Reference. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Unsubscribe-specific errors The following errors are specific to an unsubscribe operation: error value Meaning not_subscribed You tried to unsubscribe from a subscription that doesn't exist. The \"action\" field is always \"action\":\"rtm/unsubscribe/error\". Read PDU A particular message in a channel can be retrieved by sending a Read PDU request to RTM. RTM returns the message at the position specified in the request. If there is no position specified, RTM defaults to the position of the latest message in the channel. A null message in the response PDU means that there were no messages at that position. Request { \"action\":\"rtm/read\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":ChannelName, \"position\":Position OPTIONAL } } Response (ok) { \"action\":\"rtm/read/ok\", \"id\":RequestId, \"body\":{ \"position\":Position, \"message\":Message } } Response (error) { \"action\":\"rtm/read/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } Field Type Description ChannelName string The name of the channel to read from. Position string The channel location to retrieve a message at. See position in the Channels section. Message value Message returned by RTM. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. RequestId int or string See id Field in the Channels section. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Read-specific errors The following errors are specific to a read operation: error value Meaning expired_position The message at the position you tried to read from no longer exists, because RTM expired it. The \"action\" field is always \"action\":\"rtm/read/error\". Write PDU Write PDU is provided for key-value (dictionary storage) semantics: channel name represents a key and the last (and the only used) message the channel represents a value. In other words, a channel serves as a dictionary entry. Current implementation and specifications are the same as publish PDU but using write operation in action: \"action\":\"rtm/write\". Delete PDU The delete PDU is provided for key-value (dictionary storage) semantics to erase a value for a given key. The key is represented by a channel, and only the last message in the channel is relevant (represents the value). Hence, publishing a null value serves as deletion of the the previous value (if any). Sending a delete PDU request is the same as publishing or writing a null value to the channel. A delete operation requires publish permission. Request { \"action\":\"rtm/delete\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":Channel } } Response (ok) { \"action\":\"rtm/delete/ok\", \"id\":RequestId, \"body\":{ \"position\":Position OPTIONAL } } Response (error) { \"action\":\"rtm/delete/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } Field Type Description ChannelName string The name of the channel. Position string Present only in a response. Channel location at which the message has been deleted, when purge is false. When purge is true, position is not returned. See position in the Channels section. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. RequestId int or string See id field in the PDU section. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"cbor_parse_error\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Delete-specific errors The following errors are specific to a delete operation: error value Meaning expired_position The message at the position you tried to read from no longer exists, because RTM expired it. The \"action\" field is always \"action\":\"rtm/delete/error\". Using delete Deleting a channel message is the same as publishing or writing null to the channel. For example, these three requests to RTM accomplish identical result: {\"action\":\"rtm/publish\",\"body\":{\"channel\":\"x\",\"message\":null}} {\"action\":\"rtm/write\",\"body\":{\"channel\":\"x\",\"message\":null}} {\"action\":\"rtm/delete\",\"body\":{\"channel\":\"x\"}} Handshake & Authenticate PDUs RTM uses role-based authentication and authorization. Roles and their channel permissions are configured in [77]Dev Portal. When you first connect to RTM, your client is established with the default role. You can acquire different permissions by authenticating for a different role. You do this in a two-step process using the handshake and then the authenticate PDU. Handshake PDU To start the authentication process, you send a handshake PDU to obtain a nonce that you use to construct an authentication hash. If the request succeeds, RTM returns the nonce. In case of an error, RTM cancels the handshake request. For example, an error may occur if the role you specify doesn't exist in the Dev Portal. Request { \"action\":\"auth/handshake\", \"id\":RequestId OPTIONAL \"body\":{ \"method\":AuthMethod, \"data\":{ \"role\":Role } } } Response (ok) { \"action\":\"auth/handshake/ok\", \"id\":RequestId, \"body\":{ \"data\":{ \"nonce\":Nonce } } } Response (error) { \"action\":\"auth/handshake/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } } Field Type Description AuthMethod string Method of authentication to perform. Only \"role_secret\" is currently supported. Role string Role to authenticate as. Nonce string Cryptographic random value to be combined with the secret by the client to produce the hash. Hash is sent in rtm/authenticate request. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Handshake-specific errors RTM may return the following errors in response to a handshake request: error value Meaning auth_method_not_allowed In the handshake PDU, method is not set to \"role_secret\". The \"action\" field is always \"action\":\"auth/handshake/error\". Authenticate PDU You send the authenticate PDU to complete the authentication process. After authentication is complete, your client has the permissions associated with the role with which it has authenticated. In case of an error, RTM cancels the entire authentication request. This can occur, for example, if your calculated hash doesn't match the value calculated by RTM, or if the role you specify doesn't exist in the Dev Portal. Request { \"action\":\"auth/authenticate\", \"id\":RequestId OPTIONAL, \"body\":{ \"method\":AuthMethod, \"credentials\":{ \"hash\":Hash } } } Response (ok) { \"action\":\"auth/authenticate/ok\", \"id\":RequestId, \"body\":{} } Response (error) { \"action\":\"auth/authenticate/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName \"reason\":ErrorReason } } Field Type Description AuthMethod text Method of authentication to perform. Only \"role_secret\" is currently supported. Role text Role to authenticate as. Project roles and their permissions are managed in ~/.cobra.yaml file Hash string HMAC-MD5 hash value computed for the secret key and the nonce received in rtm/handshake/ok. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. Unclassified errors RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors. Authenticate-specific errors RTM may return the following errors in response to a authentication request: error value Meaning \"authentication_failed\" In your authentication PDU, the value of \"hash\" is invalid. \"auth_method_not_allowed\" In the authentication PDU, the value of \"method\" is not set to \"role_secret\". The \"action\" field is always \"action\":\"auth/authenticate/error\". Hash computation The hash is calculated for a secret key (K) and a nonce (N). The secret key is obtained from the ~/.cobra.yaml file; the nonce is received in handshake response PDU. Hash = base64( HMAC-MD5( utf8(K), utf8(N) ) ) Existing HMAC-MD5 implementations are commonly available for any language. For completeness: HMAC-MD5 is the algorithm specified in [RFC 2104] using MD5 [RFC 1321] as the underlying hash function. base64 is a string representation of a byte array described in [RFC 3548]. Note that the result of the base64 operation is the actual hash value and shall be used as it is. utf8 is the binary representation of string described in [RFC 3629]. Hash computation example Let secret key K = \"secret-key\" and nonce N = \"nonce\" utf8(K) = [73 65 63 72 65 74 2D 6B 65 79] utf8(N) = [6E 6F 6E 63 65] HMAC-MD5(utf8(SK), utf8(N)) = [1B 5D 80 F0 3B 74 45 D8 C7 37 1F 0F D2 57 22 F7] hash = 'G12A8Dt0RdjHNx8P0lci9w==' Error Reference Every error includes error and reason fields. Additional fields may be present, specific to a PDU type. Error PDU body { \"error\": string, \"reason\": text, // other PDU-specific fields } Field Description error Name of the error. This string is intended for use in code. reason Describes the error. This text is intended for human use; the text may change in the future and should not be used in code conditioning logic. Error types Errors are categorized into two types: Error Type Description Unclassified Errors not associated with a particular operation. It may be unknown which operation is triggering it, or potentially affecting overall communication consistency. For example, if RTM cannot parse a PDU or cannot parse an action, it has no choice but to return a general system error. Operation-specific Errors returned in direct response to a request sent by a client, or unsolicited errors associated with a particular operation.","title":"Api"},{"location":"api/#overview","text":"The RTM protocol is our wire protocol, which enables direct two-way communication between a client and RTM. Clients communicate with RTM by establishing a secure WebSocket connection and exchanging JSON- or CBOR-encoded units. RTM implements the publish-subscribe pattern where users publish messages to a channel and all subscribers to that channel receive those messages. The RTM API defines the structure, rules and semantics for exchanging the JSON objects. We call these JSON objects Protocol Data Units (PDUs). A PDU can carry a request to RTM to perform a particular action (such as to publish a message), its response from RTM, or an unsolicited message, such as subscription data.","title":"Overview"},{"location":"api/#message-order-guarantees","text":"RTM forwards published messages to the subscribers in the same order as it received them. The order of messages between different publishers is not guaranteed. All subscribers will receive the published messages in the same order.","title":"Message order guarantees"},{"location":"api/#protocol-data-unit-pdu","text":"","title":"Protocol Data Unit (PDU)"},{"location":"api/#definition","text":"A PDU is a unit, formatted in JSON or CBOR, with a specific structure enabling meaningful communication between RTM and clients. Each PDU is encoded into a single WebSocket frame. RTM supports UTF-8.","title":"Definition"},{"location":"api/#pdu-encoding","text":"We use custom self-explanatory \"mini schema\" to define the format of JSON PDUs. It uses JSON syntax to describe fields, followed by their type or placeholder values (which in turned are defined the same way). Fields order does not matter. See [41]Mini-schema Reference for more details. The following mini schema defines the structure of a PDU. Note that this structure holds for all PDUs in RTM API. { \"action\": string, \"id\": string | integer OPTIONAL, \"body\": object }","title":"PDU encoding"},{"location":"api/#json-pdus","text":"JSON PDUs are JSON objects. In languages other than JavaScript, use a JSON API to convert native objects to a canonical JSON form.","title":"JSON PDUs"},{"location":"api/#websocket-for-rtm","text":"Endpoint The WebSocket connection string for RTM has the syntax: <endpoint>/<rtm_version>?appkey=<appkey> : Endpoint string, for example wss://example.com : Current version of RTM, for example v2. The current version is listed at the beginning of the RTM API documentation : Appkey from ~/.cobra.yaml For example: wss://example.com/v2?appkey=46832Af7f7cba8df8Fa2Bd5CE8B7D99E","title":"WebSocket for RTM"},{"location":"api/#pdu-types","text":"A PDU can represent any of the following units of communication: * A request to RTM. A request to perform an action, for example, to publish a message. * A response from RTM. The response to a client request. * Unsolicited subscription messages from RTM. Messages as they have been published to the channel for simple subscriptions, or resulting messages for subscriptions with views. * An unsolicited error or information updates. Channel-specific informational or error messages, or system error messages, sent by RTM to the client.","title":"PDU types"},{"location":"api/#pdu-size","text":"User generated \"payload\" size is unlimited.","title":"PDU size"},{"location":"api/#pdu-fields","text":"","title":"PDU fields"},{"location":"api/#action-field","text":"The action field specifies the purpose of a PDU and determines the content of the body. The action field consists of up to three components separated by forward slash: / / . The following table explains the meaning of each component, as well as the rule for parsing it out from the full action string value: Action component Meaning Parsing rules service Name of the service responsible for handling incoming requests or sending responses and unsolicited PDUs. The first part of the action string up to the first backslash character `/'. operation Operation the client wants the service to perform. After the first backslash character \"/\" up to the outcome or end of the string. Note that it may contain backslashes as part of the operation. outcome Represents the result of the request or the type of information provided to the client. Present only in responses and unsolicited PDUs. The part after the last backslash \"/\".","title":"action field"},{"location":"api/#id-field","text":"The id field in a request PDU instructs RTM to send a response and enables a client to match a response to a request. If the id field is not present in a request, RTM does not acknowledge it: no response will be sent to a client, regardless of the outcome. Note that id field and its semantics applies to every PDU in the RTM protocol. The id field can be an integer or a string. Even though specifying id field in a request is optional, only a few cases benefit from omitting it (e.g. high throughput publishing); some operation cannot be completed without id at all (e.g. authentication). Clients should specify id in a request, unless client logic identified a concrete motivation not to do so, for a specific use case. Use the following rules and guidelines with the id field: Rule/Guideline Description Include id field to get a response from RTM In most cases, there is no significant traffic savings from omitting the id but by doing so, client forfeits an opportunity to detect failing requests (error outcome). Avoid reusing id value in different requests RTM does not enforce uniqueness on the id field. Two requests with the same id are treated as two separate requests by RTM.","title":"id field"},{"location":"api/#body-field","text":"The body field's content is specific to the PDU's action. The structure and semantics of the body field's content must be followed for each action field type. See the definitions of the specific PDU types.","title":"body field"},{"location":"api/#channels","text":"Channels are named streams of messages. A channel is unique per Dev Portal project. If two projects have channels with the same name, RTM treats them as separate channels: they have their own content, history, settings, permissions, etc.","title":"Channels"},{"location":"api/#subscription","text":"Subscriptions are clients' interest in messages published to a channel, accepted and served by RTM. In the simplest case, a subscription establishes a client's interest in all messages as they arrive in a channel. Clients may also request a subscription to include past messages (see history and position). In more involved cases, message data can be filtered or/and transformed (see [43]Views).","title":"Subscription"},{"location":"api/#position","text":"A position is a message offset relative to other messages in the channel. It uniquely identifies the location of the message in the channel and may refer to an expired (no longer stored), available (stored, retrievable), or future (not yet occupied location) message. The next channel position is the first available unoccupied position in a channel. The next published message to arrive is placed at this position. The position field can be used to read a particular message from a channel or to subscribe from a specific position, typically in order to avoid skipping messages when re-subscribing.","title":"Position"},{"location":"api/#implicit-channel-creation-and-deletion","text":"Channel instances are automatically created by RTM on demand: upon the first subscribe or publish request to a specified channel name, RTM creates a corresponding channel instance. RTM automatically garbage collects channels when it is safe to do so (channel is empty and no one has been accessing it for some time). Channel instance creation and deletion should not be confused with managing channel bookkeeping in Dev Portal, such as setting permissions or history for specific channel names or namespaces.","title":"Implicit channel creation and deletion"},{"location":"api/#channel-history","text":"In addition to forwarding published messages to all subscribers, RTM also stores all messages for at least 1 minute. Additionally, longer storage is available with channel history: users can configure how many messages should be stored for a longer period of time for a given channel. History settings are configured in Dev Portal and default to one message for 6 hours. A subscription to a channel can be requested starting at a historical message; similarly read operation can retrieve messages published in the past.","title":"Channel history"},{"location":"api/#channel-names","text":"Channel names are case sensitive. Channel names starting with character `$' are reserved by RTM.","title":"Channel names"},{"location":"api/#publish-pdu","text":"Messages can be published to a channel by sending a Publish PDU request to RTM. The following specification shows the publish request and response PDUs:","title":"Publish PDU"},{"location":"api/#request","text":"{ \"action\":\"rtm/publish\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":ChannelName, \"message\":Message } }","title":"Request"},{"location":"api/#response-ok","text":"{ \"action\":\"rtm/publish/ok\", \"id\": RequestId, \"body\":{ \"position\":Position } }","title":"Response (OK)"},{"location":"api/#response-error","text":"{ \"action\":\"rtm/publish/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } Field Type Description ChannelName string The name of the channel to publish to. Message value The message to publish to the channel. Position string The channel location of the published message. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description.","title":"Response (error)"},{"location":"api/#unclassified-errors","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#subscribe-pdu","text":"A client subscribes to a channel by sending a request Subscribe PDU to RTM.","title":"Subscribe PDU"},{"location":"api/#position_1","text":"By default, a new subscription starts at the next channel position (from the next published message, see position in [51]Channels). That is, no previously published (historic) messages are returned. A client may start a subscription at an earlier (historic) message by specifying the position in the subscribe request PDU.","title":"Position"},{"location":"api/#subscription_id","text":"A subscription is identified by the subscription_id field. Multiple subscriptions can be made to the same channel, as long as different subscription id's are used. For a subscription without a view (default), the subscription_id must be equal to the channel name, and is optional. For a subscription with a view, the subscription_id field is required and the channel field is optional (the channel name must match what is specified in the filter (view) field).","title":"subscription_id"},{"location":"api/#subscribe-without-streamview-no-filter-field","text":"","title":"Subscribe without streamview (no filter field)"},{"location":"api/#request_1","text":"{ \"action\":\"rtm/subscribe\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":ChannelName, \"subscription_id\":SubId OPTIONAL, \"force\":Force OPTIONAL, \"fast_forward\":FastForward OPTIONAL, \"position\":Position OPTIONAL, \"history\":{ \"count\":Count OPTIONAL, \"age\":Age OPTIONAL } OPTIONAL } }","title":"Request"},{"location":"api/#response-ok_1","text":"{ \"action\":\"rtm/subscribe/ok\", \"id\":RequestId \"body\":{ \"position\":Position, \"subscription_id\":SubId } }","title":"Response (ok)"},{"location":"api/#response-error_1","text":"{ \"action\":\"rtm/subscribe/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason OPTIONAL, \"subscription_id\":SubId } }","title":"Response (error)"},{"location":"api/#subscribe-with-streamview-filter-field","text":"","title":"Subscribe with streamview (filter field)"},{"location":"api/#request_2","text":"{ \"action\":\"rtm/subscribe\", \"id\":RequestId OPTIONAL, \"body\":{ \"filter\":SQL, \"subscription_id\":SubId, \"force\":Force OPTIONAL, \"fast_forward\":FastForward OPTIONAL, \"period\":Period OPTIONAL, \"position\":Position OPTIONAL, \"history\":{ \"count\":Count OPTIONAL, \"age\":Age OPTIONAL } OPTIONAL } }","title":"Request"},{"location":"api/#response-ok_2","text":"{ \"action\":\"rtm/subscribe/ok\", \"id\":RequestId, \"body\":{ \"position\":Position, \"subscription_id\":SubId } }","title":"Response (ok)"},{"location":"api/#response-error_2","text":"{ \"action\":\"rtm/subscribe/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason OPTIONAL, \"subscription_id\":SubId } } Field Type Description ChannelName string The name of the channel to subscribe to. SubId string Either a channel name or a unique client-generated identifier for the subscription (when applicable) Position string Channel location to start the subscription at. Default is the next channel position. SQL string SQL statement to run on messages before sending them to the client. See Views. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. RequestId int or string See id field in PDU section.","title":"Response (error)"},{"location":"api/#unclassified-errors_1","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#subscribe-specific-errors","text":"error value Meaning already_subscribed You requested a new subscription with subscription_id set to an active subscription id, and you didn't specify \"force\" : true. expired_position RTM expired the message at the position you specified in position. The message is no longer available. invalid_filter (for a streamview subscription only): The stream SQL you specified in filter is invalid. subscription_quota_exceeded You tried to add a subscription or streamview, but you exceeded the quota for the number of subscriptions or streamviews per project. The \"action\" field is always \"action\":\"rtm/subscribe/error\".","title":"Subscribe-specific errors"},{"location":"api/#out_of_sync-and-fast_forward","text":"RTM sends subscription messages to the client as fast as the physical network link to the client allows it. If the rate of incoming (published) messages is higher than the outgoing rate (rate at which messages are delivered to a particular client subscription), we say that a client subscription is falling behind. If this situation persists, undelivered messages accumulate on the RTM side and eventually RTM expires (deletes) them. By default, messages are deleted after 60 seconds and the last message in a channel - after 6h. We call this situation out_of_sync: messages stream continuity cannot be sustained for a subscriber; message drop is inevitable. Subscriber can change this behavior by setting the fast_forward field to true in the request Subscribe PDU. In this case, RTM \"fast-forwards\" the client to the oldest not yet deleted message, instead of forcing unsubscription, and sends an info Subscription PDU.","title":"out_of_sync and fast_forward"},{"location":"api/#updating-a-subscription","text":"filter and period fields can be changed on-the-fly for a pre-existing active subscription: by sending a Subscribe PDU with the force field set to true. Without \"force\":true, RTM responds with an already_subscribed error and does not update the current subscription.","title":"Updating a subscription"},{"location":"api/#subscription-pdus-unsolicited","text":"RTM sends subscription data (channel messages) or subscription related status (info or error) using subscription PDUs. Subscription PDU can be: * data. A subscription data PDU delivers channel messages (possibly filtered and transformed messages in case of a viewed subscription). Note that a single subscription data PDU can contain multiple messages grouped in the array messages field (for optimization purposes). * info. A subscription Info PDU contains information about a subscription, which includes the type of info and the reason why RTM sent it. For a fast_forward info, it also includes the count of skipped messages due to RTM fast-forwarding the subscription. * error. A subscription error PDU notifies of subscription termination (forceful unsubscription) due to a subscription-related error. For example, if a client subscription falls behind and fast-forward has not been enabled, RTM sends an out_of_sync error and unsubscribes the client (see out_of_sync in [60]Subscribe PDU section).","title":"Subscription PDUs (unsolicited)"},{"location":"api/#subscription-data","text":"{ \"action\":\"rtm/subscription/data\", \"body\":{ \"position\":Position, \"messages\":[Message]*, \"subscription_id\":SubId } }","title":"Subscription data"},{"location":"api/#subscription-info","text":"{ \"action\":\"rtm/subscription/info\", \"body\":{ \"info\":InfoType, \"reason\":InfoReason, \"position\":Position, \"subscription_id:SubId, \"missed_message_count\":Count OPTIONAL } }","title":"Subscription info"},{"location":"api/#subscription-error","text":"{ \"action\":\"rtm/subscription/error\", \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason, \"position\":Position, \"subscription_id\":SubId, \"missed_message_count\":Count OPTIONAL } } Field Type Description Position string Provided to enable clients to resubscribe preserving stream continuity (in the event of a disconnect). Message value A channel message (as it was published, or - when applicable - a message result according to the subscription view) SubId string Id for the subscription for which the PDU was sent. InfoType string Information type. See Service-Specific Info Messages. InfoReason text In the sections following this table, see \"Unsolicited subscribe info messages\". Count int Number of skipped messages in the channel. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See [62]Error Reference.","title":"Subscription error"},{"location":"api/#unsolicited-subscribe-errors","text":"RTM may return one of these errors for an active subscription: error value Meaning out_of_sync The message position for the subscription is pointing to an expired message, and your subscribe PDU didn't specify \"fast_forward\" : true. RTM unsubscribes you, and it may drop your connection. expired_position Your subscribe PDU specified the \"position\" field, but its value points to an expired message. The \"action\" field is always \"action\":\"rtm/subscription/error\".","title":"Unsolicited subscribe errors"},{"location":"api/#unsolicited-subscribe-info-messages","text":"RTM may return this info message for an active subscription: info value Meaning fast_forward Because your subscribe PDU specified \"fast_forward\" : true, RTM performed a fast forward in response to an out of sync condition. You receive this info PDU in addition to an error PDU with error set to \"expired_position\". The \"action\" field is always \"action\":\"rtm/subscription/info\".","title":"Unsolicited subscribe info messages"},{"location":"api/#unsubscribe-pdu","text":"A subscriber requests to terminate its subscription by sending an Unsubscribe PDU request to RTM. In case a client endpoint has multiple subscriptions to the same channel, it must send a PDU for each subscription it wants to end.","title":"Unsubscribe PDU"},{"location":"api/#request_3","text":"{ \"action\":\"rtm/unsubscribe\", \"id\":RequestId OPTIONAL, \"body\":{ \"subscription_id\":SubId } }","title":"Request"},{"location":"api/#response-ok_3","text":"{ \"action\":\"rtm/unsubscribe/ok\", \"id\":RequestId, \"body\":{ \"position\":Position, \"subscription_id\":SubId } }","title":"Response (ok)"},{"location":"api/#response-error_3","text":"{ \"action\":\"rtm/unsubscribe/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason, \"subscription_id\":SubId OPTIONAL } } Field Type Description SubId string Id of the subscription that you want to cancel. Position string RTM response includes current location in the channel message stream at the time unsubscribe operation has completed. Enables a client to resubscribe to the channel from the position where it unsubscribed ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See [64]Error Reference.","title":"Response (error)"},{"location":"api/#unclassified-errors_2","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#unsubscribe-specific-errors","text":"The following errors are specific to an unsubscribe operation: error value Meaning not_subscribed You tried to unsubscribe from a subscription that doesn't exist. The \"action\" field is always \"action\":\"rtm/unsubscribe/error\".","title":"Unsubscribe-specific errors"},{"location":"api/#read-pdu","text":"A particular message in a channel can be retrieved by sending a Read PDU request to RTM. RTM returns the message at the position specified in the request. If there is no position specified, RTM defaults to the position of the latest message in the channel. A null message in the response PDU means that there were no messages at that position.","title":"Read PDU"},{"location":"api/#request_4","text":"{ \"action\":\"rtm/read\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":ChannelName, \"position\":Position OPTIONAL } }","title":"Request"},{"location":"api/#response-ok_4","text":"{ \"action\":\"rtm/read/ok\", \"id\":RequestId, \"body\":{ \"position\":Position, \"message\":Message } }","title":"Response (ok)"},{"location":"api/#response-error_4","text":"{ \"action\":\"rtm/read/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } Field Type Description ChannelName string The name of the channel to read from. Position string The channel location to retrieve a message at. See position in the Channels section. Message value Message returned by RTM. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. RequestId int or string See id Field in the Channels section.","title":"Response (error)"},{"location":"api/#unclassified-errors_3","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#read-specific-errors","text":"The following errors are specific to a read operation: error value Meaning expired_position The message at the position you tried to read from no longer exists, because RTM expired it. The \"action\" field is always \"action\":\"rtm/read/error\".","title":"Read-specific errors"},{"location":"api/#write-pdu","text":"Write PDU is provided for key-value (dictionary storage) semantics: channel name represents a key and the last (and the only used) message the channel represents a value. In other words, a channel serves as a dictionary entry. Current implementation and specifications are the same as publish PDU but using write operation in action: \"action\":\"rtm/write\".","title":"Write PDU"},{"location":"api/#delete-pdu","text":"The delete PDU is provided for key-value (dictionary storage) semantics to erase a value for a given key. The key is represented by a channel, and only the last message in the channel is relevant (represents the value). Hence, publishing a null value serves as deletion of the the previous value (if any). Sending a delete PDU request is the same as publishing or writing a null value to the channel. A delete operation requires publish permission.","title":"Delete PDU"},{"location":"api/#request_5","text":"{ \"action\":\"rtm/delete\", \"id\":RequestId OPTIONAL, \"body\":{ \"channel\":Channel } }","title":"Request"},{"location":"api/#response-ok_5","text":"{ \"action\":\"rtm/delete/ok\", \"id\":RequestId, \"body\":{ \"position\":Position OPTIONAL } }","title":"Response (ok)"},{"location":"api/#response-error_5","text":"{ \"action\":\"rtm/delete/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } Field Type Description ChannelName string The name of the channel. Position string Present only in a response. Channel location at which the message has been deleted, when purge is false. When purge is true, position is not returned. See position in the Channels section. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference. RequestId int or string See id field in the PDU section.","title":"Response (error)"},{"location":"api/#unclassified-errors_4","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"cbor_parse_error\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#delete-specific-errors","text":"The following errors are specific to a delete operation: error value Meaning expired_position The message at the position you tried to read from no longer exists, because RTM expired it. The \"action\" field is always \"action\":\"rtm/delete/error\".","title":"Delete-specific errors"},{"location":"api/#using-delete","text":"Deleting a channel message is the same as publishing or writing null to the channel. For example, these three requests to RTM accomplish identical result: {\"action\":\"rtm/publish\",\"body\":{\"channel\":\"x\",\"message\":null}} {\"action\":\"rtm/write\",\"body\":{\"channel\":\"x\",\"message\":null}} {\"action\":\"rtm/delete\",\"body\":{\"channel\":\"x\"}}","title":"Using delete"},{"location":"api/#handshake-authenticate-pdus","text":"RTM uses role-based authentication and authorization. Roles and their channel permissions are configured in [77]Dev Portal. When you first connect to RTM, your client is established with the default role. You can acquire different permissions by authenticating for a different role. You do this in a two-step process using the handshake and then the authenticate PDU.","title":"Handshake &amp; Authenticate PDUs"},{"location":"api/#handshake-pdu","text":"To start the authentication process, you send a handshake PDU to obtain a nonce that you use to construct an authentication hash. If the request succeeds, RTM returns the nonce. In case of an error, RTM cancels the handshake request. For example, an error may occur if the role you specify doesn't exist in the Dev Portal.","title":"Handshake PDU"},{"location":"api/#request_6","text":"{ \"action\":\"auth/handshake\", \"id\":RequestId OPTIONAL \"body\":{ \"method\":AuthMethod, \"data\":{ \"role\":Role } } }","title":"Request"},{"location":"api/#response-ok_6","text":"{ \"action\":\"auth/handshake/ok\", \"id\":RequestId, \"body\":{ \"data\":{ \"nonce\":Nonce } } }","title":"Response (ok)"},{"location":"api/#response-error_6","text":"{ \"action\":\"auth/handshake/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName, \"reason\":ErrorReason } } } Field Type Description AuthMethod string Method of authentication to perform. Only \"role_secret\" is currently supported. Role string Role to authenticate as. Nonce string Cryptographic random value to be combined with the secret by the client to produce the hash. Hash is sent in rtm/authenticate request. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference.","title":"Response (error)"},{"location":"api/#unclassified-errors_5","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#handshake-specific-errors","text":"RTM may return the following errors in response to a handshake request: error value Meaning auth_method_not_allowed In the handshake PDU, method is not set to \"role_secret\". The \"action\" field is always \"action\":\"auth/handshake/error\".","title":"Handshake-specific errors"},{"location":"api/#authenticate-pdu","text":"You send the authenticate PDU to complete the authentication process. After authentication is complete, your client has the permissions associated with the role with which it has authenticated. In case of an error, RTM cancels the entire authentication request. This can occur, for example, if your calculated hash doesn't match the value calculated by RTM, or if the role you specify doesn't exist in the Dev Portal.","title":"Authenticate PDU"},{"location":"api/#request_7","text":"{ \"action\":\"auth/authenticate\", \"id\":RequestId OPTIONAL, \"body\":{ \"method\":AuthMethod, \"credentials\":{ \"hash\":Hash } } }","title":"Request"},{"location":"api/#response-ok_7","text":"{ \"action\":\"auth/authenticate/ok\", \"id\":RequestId, \"body\":{} }","title":"Response (ok)"},{"location":"api/#response-error_7","text":"{ \"action\":\"auth/authenticate/error\", \"id\":RequestId, \"body\":{ \"error\":ErrorName \"reason\":ErrorReason } } Field Type Description AuthMethod text Method of authentication to perform. Only \"role_secret\" is currently supported. Role text Role to authenticate as. Project roles and their permissions are managed in ~/.cobra.yaml file Hash string HMAC-MD5 hash value computed for the secret key and the nonce received in rtm/handshake/ok. ErrorName string Possible errors are listed in the sections following this table. ErrorReason text Human readable error description. See Error Reference.","title":"Response (error)"},{"location":"api/#unclassified-errors_6","text":"RTM may return the following unclassified errors: \"authorization_denied\" \"invalid_format\" \"invalid_operation\" \"invalid_service\" \"json_parse_error\" To learn more about any of these errors, see Unclassified Errors.","title":"Unclassified errors"},{"location":"api/#authenticate-specific-errors","text":"RTM may return the following errors in response to a authentication request: error value Meaning \"authentication_failed\" In your authentication PDU, the value of \"hash\" is invalid. \"auth_method_not_allowed\" In the authentication PDU, the value of \"method\" is not set to \"role_secret\". The \"action\" field is always \"action\":\"auth/authenticate/error\".","title":"Authenticate-specific errors"},{"location":"api/#hash-computation","text":"The hash is calculated for a secret key (K) and a nonce (N). The secret key is obtained from the ~/.cobra.yaml file; the nonce is received in handshake response PDU. Hash = base64( HMAC-MD5( utf8(K), utf8(N) ) ) Existing HMAC-MD5 implementations are commonly available for any language. For completeness: HMAC-MD5 is the algorithm specified in [RFC 2104] using MD5 [RFC 1321] as the underlying hash function. base64 is a string representation of a byte array described in [RFC 3548]. Note that the result of the base64 operation is the actual hash value and shall be used as it is. utf8 is the binary representation of string described in [RFC 3629].","title":"Hash computation"},{"location":"api/#hash-computation-example","text":"Let secret key K = \"secret-key\" and nonce N = \"nonce\" utf8(K) = [73 65 63 72 65 74 2D 6B 65 79] utf8(N) = [6E 6F 6E 63 65] HMAC-MD5(utf8(SK), utf8(N)) = [1B 5D 80 F0 3B 74 45 D8 C7 37 1F 0F D2 57 22 F7] hash = 'G12A8Dt0RdjHNx8P0lci9w=='","title":"Hash computation example"},{"location":"api/#error-reference","text":"Every error includes error and reason fields. Additional fields may be present, specific to a PDU type. Error PDU body { \"error\": string, \"reason\": text, // other PDU-specific fields } Field Description error Name of the error. This string is intended for use in code. reason Describes the error. This text is intended for human use; the text may change in the future and should not be used in code conditioning logic.","title":"Error Reference"},{"location":"api/#error-types","text":"Errors are categorized into two types: Error Type Description Unclassified Errors not associated with a particular operation. It may be unknown which operation is triggering it, or potentially affecting overall communication consistency. For example, if RTM cannot parse a PDU or cannot parse an action, it has no choice but to return a general system error. Operation-specific Errors returned in direct response to a request sent by a client, or unsolicited errors associated with a particular operation.","title":"Error types"},{"location":"sdk/","text":"There are currently 3 languages that have an sdk to communicate with a cobra server. Python (the cobras modules itself). C++. The cobra sdk code is part of IXWebSocket, under the ixcobra folder. Javascript. The code can be found in the cobra python repository, here . We will try to publish it to npm, and maybe make it its own repo.","title":"Sdk"}]}